# Development Process

このドキュメントは、DevCardバックエンドにおける開発の哲学と進め方を定義します。

## 開発の基本原則

### 1. いきなり実装しない

新しい機能や変更を入れる際、**いきなりコードを書き始めない**。

まず以下を明確にする：
- 何を変えるのか（どのエンドポイント、どのデータモデル）
- なぜ変えるのか（ユーザー価値、ビジネス要求）
- 誰に影響するのか（どのクライアント、どのユーザー）

### 2. 影響範囲を明文化する

変更の影響を以下の観点で分析する：
- **API契約への影響**: リクエスト/レスポンス構造の変更
- **データベースへの影響**: スキーマ変更、マイグレーション必要性
- **認証/認可への影響**: 権限モデルの変更
- **破壊的変更の有無**: 既存クライアントが動かなくなるか

### 3. テストケースを定義する

実装前に、以下を列挙する：
- **成功系**: 正常に動作するケース
- **失敗系**: バリデーションエラー、権限不足、データ不整合など

これらを自然言語で書いておく。コードはまだ書かない。

## .work/item.json の位置づけ

すべてのAPI変更・追加は、**.work/item.json** という単一のメタ情報ファイルで追跡する。

### 役割

- **作業開始から同期PR生成までの唯一の真実**
- 意図（なぜ変えるか）、影響（どこに影響するか）、クライアント側TODO（何を直す必要があるか）を一箇所に集約
- 人間とAIの会話、バックエンド→フロントエンドの引き継ぎ、すべてこのファイルを参照

### ライフサイクル

1. **作業開始時（計画フェーズ）**: 新規作成または既存ファイルを更新、`status: "draft"` に設定
2. **テスト作成時**: `tests_required[]` を参照してテストケースを実装
3. **実装完了時**: `security_notes[]`, `breaking_changes` を確定、`status: "ready-for-review"` に変更
4. **PRマージ時**: `status: "merged"`, `backend_commit_sha` を確定
5. **同期PR生成時**: `.sync-metadata.json` として変換され、フロントエンドリポジトリへ同期

### スキーマ

詳細は `.work/item.schema.json` を参照。

主要フィールド：
- `feature_name`: 変更の名前
- `status`: "draft" | "ready-for-review" | "merged"
- `api_changes[]`: エンドポイント変更のリスト
- `tests_required[]`: 実装すべきテストケース
- `client_work_items[]`: フロントエンド側のTODO
- `breaking_changes`: 破壊的変更フラグ
- `security_notes[]`: セキュリティ・認可の考慮事項
- `notes_for_frontend`: フロントエンド開発者への自然言語指示

### 更新タイミング

各開発ステップで必ず更新する（詳細は後述の各ステップを参照）。

## テスト駆動開発のフロー

### ステップ0: .work/item.json の作成/更新

**最初に必ず実施**：

1. `.work/item.json` が存在しない場合、`.work/item.json.example` をコピー
2. 以下のフィールドを埋める：
   - `feature_name`: この変更の名前
   - `api_changes[]`: 変更するエンドポイントと詳細
   - `tests_required[]`: 実装すべきテストケース
   - `client_work_items[]`: フロントエンド側で必要な作業
   - `security_notes[]`: セキュリティ上の考慮事項
   - `breaking_changes`: 破壊的変更かどうか
3. `status` を `"draft"` に設定

この時点で、意図・影響・作業範囲がすべて文書化される。

### ステップ1: テストを書く（🔴 Red）

**.work/item.json の `tests_required[]` を参照**して、テストケースをコードとして表現する。

- 単体テスト（UseCase単位）
- 結合テスト（Cloud Functions呼び出し）

この時点では**テストは失敗する**。それで正しい。

### ステップ2: 実装する（🟢 Green）

テストを通すための最小限の実装を書く。

実装の順序：
1. Domain層: エンティティ、ドメインロジック
2. Application層: UseCase
3. Infrastructure/Handler層: 外部連携、エントリーポイント

### ステップ3: 検証する（✅ Verify）

すべてのテストとリントを通す。

```bash
npm run lint
npm test
```

この時点での挙動が「正」となる。

### ステップ4: API契約を更新する

実装が確定したら、`contracts/` 配下のファイルを更新する：

- `contracts/API_CONTRACT.md`: エンドポイント仕様
- `contracts/openapi.yaml`: OpenAPI定義
- `contracts/CHANGELOG.md`: 変更履歴

**重要**: テストが通る前に契約を書き換えてはならない。実装が「正」であり、契約はそれを記述するものである。

**.work/item.json の更新**：

- `breaking_changes` フラグを確定（api_changes[] のいずれかが破壊的な場合は `true`）
- `status` を `"ready-for-review"` に変更
- `security_notes[]` が実装に反映されているか確認

### ステップ5: 差分を同期する

PRがdevelopにマージされると、以下が自動実行される：

1. **GitHub Actions による同期**：
   - `.work/item.json` を直接読み込む
   - `backend_commit_sha` を `git rev-parse HEAD` で取得
   - `contracts/` のみをフロントエンドリポジトリへ同期（.work/ は除外）
   - `.work/item.json` の内容を元に、フロントエンドリポジトリへPRとIssueを自動作成
   - `client_work_items[]` がそのままフロントエンド側のTODOリストになる
   - `notes_for_frontend` がフロントエンド開発者への指示となる

これにより、バックエンドの意図と影響がフロントエンドチームに正確に伝わる。

**重要**: `.work/` ディレクトリはバックエンド内部の作業管理用であり、フロントエンドには同期されない。

## この順序を守る理由

- **仕様の曖昧さを排除**: テストが仕様書になる
- **リグレッション防止**: すべての振る舞いがテストで保護される
- **契約の正確性**: 実装と契約の乖離を防ぐ
- **チーム連携**: 変更が自動的に共有される

## アンチパターン

以下は**やってはいけない**開発の進め方：

❌ テストなしで実装する
❌ テストを実装に合わせて修正する（実装が間違っている可能性を無視）
❌ リントエラーを残したままコミットする
❌ 契約を更新せずにAPIを変更する
❌ 破壊的変更を明記せずにマージする

---

**注意**: このドキュメントは開発の「順序」と「哲学」を記述するものであり、特定のツールやコマンドへの依存を強制するものではありません。
